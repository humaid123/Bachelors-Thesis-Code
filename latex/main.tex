\documentclass{article}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{float} %figure inside minipage
\graphicspath{ {./images/} }
\usepackage[export]{adjustbox}
\usepackage{apacite}
\usepackage{amsmath}

\begin{document}
\section{Abstract}
In this paper, we consider the problems of solving ordinary differential equation (ODE) models and partial differential equation (PDE) models with discontinuities. We then tackle the issues of providing continuous solutions to ODE problems through an efficient `defect control' scheme using multistep interpolants. 

Using a Covid-19 ODE model with discontinuities and the R, Python, Scilab and Matlab programming environment and discuss how to handle problems with time- and state-dependent discontinuities. Using a Covid-19 PDE model with a PDE solver with event detection capabilities, BACOLIKR, we discuss the issues and solutions to PDE models with time- and state-dependent discontinuities. 

Using multistep interpolants (Hermite-Birkhoff interpolants), we provide free $4^{th}$, $6^{th}$ and $8^{th}$ order interpolants that can be used to perform defect control. We tackle several of the issues of such an approach and show how we obtain effective defect controlled continuous solutions. 

\section{Introduction}
This thesis considers three projects. The first two chapters address the problems of solving Covid-19 ordinary differential equations (ODE) with discontinuities and Covid-19 partial differential equations (PDE) models with discontinuities, respectively. The last chapter discusses an efficient approach for controlling the size of the defect of a continuous approximate solution to an ODE. The defect is the amount by which the continuous approximate solution fails to satisfy the ODE. 

\subsection{Performance analysis of ODE solvers on Covid-19 ODE models with discontinuities}
In this chapter, we discuss the solution to discontinuous models as they arise in the ODE case. The mathematical theories that underlie modern numerical ODE solvers are built on the requirement that the function that defines the ODE model, $f(t, y(t))$, and some of its higher derivatives are continuous. Therefore, discontinuities that are introduced into ODE problems, even through simple if-statements, can drastically change performance of an ODE solver. In this chapter, we will analyse the performance of ODE software on a Covid-19 ODE model to which we will introduce (i) a time-dependent discontinuity of (ii) a state-dependent discontinuity. We will show that with a sufficiently sharp tolerance, the time-dependent discontinuity problem can be solved by most solvers but that using a form of discontinuity handling drastically improves the efficiency. We will then show that special care needs to be taken to solve state-dependent discontinuity problems and show how `event detection' allows for efficient and accurate results to be obtained. Event detection or root-finding is the capabilities of modern solvers to detect roots of the solution being computed. The user provides a root-definition function which returns 0 when a root is present and an `event detection' solver will additionally check for such a root as it integrates through a problem.

\subsection{Performance analysis of PDE solvers on Covid-19 PDE models with discontinuities}
In this chapter, we discuss the solution to discontinuous Covid-19 PDE problems. As was the case with ODEs, PDE solvers are not expected to perform well when faced with a discontinuous PDE problem. Using a Covid-19 PDE model to which we introduce a time-dependent or a state-dependent discontinuity, we will show that BACOLIKR, 8888 Reference to BACOLIRK 8888, the only PDE solver which to our knowledge can do event detection, can solve time-dependent discontinuity problems without additional precautions using a sufficiently sharp tolerance but that it does so more efficiently with discontinuity handling. We will then show that its `event detection' capability allows it to solve the state-dependent discontinuity problem which it otherwise cannot.

\subsection{Efficient defect control using multistep interpolants}
In this chapter we discuss the concept of `defect control'. We discuss its importance and the efficiency issues associated with writing efficient solvers that can control the `maximum defect' of a continuous approximate solution. Standard approaches typically makes use of continuous Runge-Kutta methods to perform defect control which typically involves performing several function evaluations of the right hand side function of the ODE, $f(t, y(t))$. In this chapter, we consider an approach to perform defect control using a multistep Hermite-Birkhoff interpolant that requires no additional function evaluations. We will augment $4^{th}$, $6^{th}$ and $8^{th}$ order Runge Kutta methods with a Hermite cubic, with a sixth order Hermite-Birkhoff interpolant and then with an eighth order Hermite-Birkhoff interpolant and show that these interpolants can be obtained using no extra function evaluations. We will discuss the challenges associated with this approach and how these challenges can be addressed. We then conclude with suggestions for additional work that can be done on this project.

\section{Conclusions and Future Work}
\subsection{Conclusions}
\subsubsection{Performance analysis of ODE solvers on Covid-19 ODE models with discontinuities}
In this chapter, we discussed issues associated with Covid-19 ODE modeling including stability issues and discontinuity issues as measures are introduced. We also discussed some of the issues with some of the programming environments. Using several solvers from across 4 different programming environments, we have shown that time-dependent discontinuity problems can be solved with a sufficiently sharp tolerance but that discontinuity handling with cold starts drastically improves the efficiency of the computations. We then showed that state-dependent discontinuity problems cannot be solved naively even at sharp tolerances and discussed why this was the case. We then discussed event detection and how to use it to efficiently solve state-dependent problems. We have shown that event detection can provide efficient and accurate solutions to state-dependent discontinuity problems.

\subsubsection{Performance analysis of PDE solvers on Covid-19 PDE models with discontinuities}
In this chapter, we have discussed Covid-19 PDE problems with time-dependent and state-dependent discontinuities and showed the efficiency and accuracy of BACOLIKR when solving these problems. We have shown that BACOLIKR can solve the time-dependent problem naively but that discontinuity handling through cold starts can improve the efficiency. We have shown that BACOLIKR cannot solve the state-dependent discontinuity problem naively and how the use of event detection allows it to solve the problem at a reasonable tolerance.  

\subsubsection{Efficient defect control using multistep interpolants}
In this chapter, we discussed the importance of defect control and the challenges that the standard approach faces in implementing it. We then introduced and derived a $4^{th}$, $6^{th}$ and $8^{th}$ order Hermite-Birkhoff interpolants (HB4, HB6, HB8) that was used to augment the Classical $4^{th}$ order Runge-Kutta method. We showed that HB4 is not an appropriate way to provide an interpolant for defect control of RK4 as the interpolation error in the derivative is of a lower order than the numerical solution. We then showed that HB6 provides reliable and efficient defect control and that HB8 does not provide much of an improvement over HB6 for defect control of RK4. We next showed how the HB6 and HB8 interpolants can be used to augment $6^{th}$ and $8^{th}$ order Runge-Kutta methods to allow them to provide efficient defect control. We then discussed the major issue with this scheme in that the derivative formula contains an $O(\frac{1}{h})$ term and thus the accuracy forms a V-shape with the step-size, $h$. We tried to remedy the rounding-off problem using the Horner and Barycentric form of the interpolants instead of using the monomial forms. We showed how the Horner's method does not improve the accuracy by much but that the Barycentric method has some significant improvements. We also noted that at an experiment optimal step-size, $h$, we have seen that the solvers do reach machine round-off. We also noted throughout the chapter that the multistep interpolants HB6 and HB8 have accuracies that rely on their step-size parameters, $\alpha$ and $\beta$, being close to 1. We then discussed an interpolant that forces these parameters to be 1 by using the evaluations of previous interpolants.

\subsection{Future Work}
\subsubsection{Performance analysis of ODE solvers on Covid-19 ODE models with discontinuities}
In this chapter, we have identified an issue with the method of obtaining output points that some of the solvers apply. We have shown how this leads to a decrease in efficiency. Potential future work in this area is to develop/use newer and less computationally expensive interpolants so that the solver uses an interpolant of sufficiently high order.

We have also discovered an issue with the RADAU5 algorithm since several environments and the Fortran code itself failed to provide a reasonable solution to the state-dependent discontinuity problem. As future work, we could look to investigate this issue. 

\subsubsection{Performance analysis of PDE solvers on Covid-19 PDE models with discontinuities}
In this section, we have identified that event detection has allowed us to solve the state-dependent discontinuity problem when even sharp tolerances did not allow us to solve the problem with the naive approach. Event detection is relatively new in the context of PDEs and identifying and understanding other problems that it now allows us to solve could be potential future work.

Another important future work is to promote and write wrappers for BACOLIKR across several programming environments so that it is easier to use. This will allow more people to access event detection for PDE problems and could potentially allow them to solve harder problems. 

=======================================
As we have noted in this chapter, the current implementation had the root location at different places due to using the same tolerance for the root-finding algorithm as it did for the numerical PDE solution. A sharper tolerances than the user-provided tolerance could potentially be used for the root-finding algorithm at some cost in efficiency. Another potential future work is to analyse how using a sharper tolerance for the root-finding algorithm reduces the efficiency of the solver.
=======================================

\subsubsection{Efficient defect control using multistep interpolants}
Throughout this chapter we have used the exact solution values for the first few steps in order to allow us to create the first interpolant. Another important research project in this area is to try different techniques including but not limited to the CRK, error control with a sharper tolerance than the user provided tolerance, and possibly other methods to perform the first step.

We can also look into developing interpolants that could lead to asymptotically correct defect control. This would guarantee that the maximum defect is always at a specific spot within each step and would thus only require one function evaluation to sample the defect.

In the section where we considered the development of HB8, we have shown how having two weight parameters on the same side and thus aggregating in the error term (as in $\alpha + \beta$), will lead to innacurate results as this scheme only provided an accurate result when all the weight parameters were equal to 1. Even a slight deviation from that value lead to poor accuracy and thus the scheme was unusable in an adaptive algorithm as we expect the step-size to change multiple times. An idea for future work is to derive a $10^{th}$ order interpolant. Such an interpolant will be forced to use 3 step-size parameters but an idea is to fix one or more of the parameters at 1. This can be done by using the technique that we employed in Section 8888 reference to section about static alpha 88888 or by using another technique such as computing a solution value in the middle of the step $[x_{i-1}, x_i]$ using the previous interpolant and performing an additional function evaluation at that data point to obtain the two values required to build an interpolant. Thus we get to use just two parameters $\alpha$ and $\beta$ for the step from $x_i$ to $x_{i+1}$ and the step from $x_{i-2}$ to $x_{i+1}$.  This will give the required 10 data points to produce such an interpolant which could then be used to augment RK8 to provide a more efficient defect control scheme for the $8^{th}$ order case. 

Another idea is to do error control instead of defect control. We would thus need a way to create two interpolants, one of a higher order and one of a lower order and sample the difference between these two interpolants to estimate the error of the continuous solution approximation. A step-size selection algorithm based on that error estimate could provide an effective error controlled solution.

\end{document}